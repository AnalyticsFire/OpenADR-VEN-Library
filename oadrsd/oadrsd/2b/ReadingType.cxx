// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ReadingType.hxx"

#include "AccumulationKind.hxx"

#include "CommodityKind.hxx"

#include "Int16.hxx"

#include "Currency.hxx"

#include "DataQualifierKind.hxx"

#include "QualityOfReading.hxx"

#include "FlowDirectionKind.hxx"

#include "UInt32.hxx"

#include "MeasurementKind.hxx"

#include "PhaseCodeKind.hxx"

#include "UnitMultiplierKind.hxx"

#include "TimePeriodOfInterest.hxx"

#include "UnitSymbolKind.hxx"

#include "ReadingInterharmonic.hxx"

#include "TimeAttributeKind.hxx"

#include "RationalNumber.hxx"

namespace espi
{
  // ReadingType
  // 

  const ReadingType::accumulationBehaviour_optional& ReadingType::
  accumulationBehaviour () const
  {
    return this->accumulationBehaviour_;
  }

  ReadingType::accumulationBehaviour_optional& ReadingType::
  accumulationBehaviour ()
  {
    return this->accumulationBehaviour_;
  }

  void ReadingType::
  accumulationBehaviour (const accumulationBehaviour_type& x)
  {
    this->accumulationBehaviour_.set (x);
  }

  void ReadingType::
  accumulationBehaviour (const accumulationBehaviour_optional& x)
  {
    this->accumulationBehaviour_ = x;
  }

  void ReadingType::
  accumulationBehaviour (::std::unique_ptr< accumulationBehaviour_type > x)
  {
    this->accumulationBehaviour_.set (std::move (x));
  }

  const ReadingType::commodity_optional& ReadingType::
  commodity () const
  {
    return this->commodity_;
  }

  ReadingType::commodity_optional& ReadingType::
  commodity ()
  {
    return this->commodity_;
  }

  void ReadingType::
  commodity (const commodity_type& x)
  {
    this->commodity_.set (x);
  }

  void ReadingType::
  commodity (const commodity_optional& x)
  {
    this->commodity_ = x;
  }

  void ReadingType::
  commodity (::std::unique_ptr< commodity_type > x)
  {
    this->commodity_.set (std::move (x));
  }

  const ReadingType::consumptionTier_optional& ReadingType::
  consumptionTier () const
  {
    return this->consumptionTier_;
  }

  ReadingType::consumptionTier_optional& ReadingType::
  consumptionTier ()
  {
    return this->consumptionTier_;
  }

  void ReadingType::
  consumptionTier (const consumptionTier_type& x)
  {
    this->consumptionTier_.set (x);
  }

  void ReadingType::
  consumptionTier (const consumptionTier_optional& x)
  {
    this->consumptionTier_ = x;
  }

  void ReadingType::
  consumptionTier (::std::unique_ptr< consumptionTier_type > x)
  {
    this->consumptionTier_.set (std::move (x));
  }

  const ReadingType::currency_optional& ReadingType::
  currency () const
  {
    return this->currency_;
  }

  ReadingType::currency_optional& ReadingType::
  currency ()
  {
    return this->currency_;
  }

  void ReadingType::
  currency (const currency_type& x)
  {
    this->currency_.set (x);
  }

  void ReadingType::
  currency (const currency_optional& x)
  {
    this->currency_ = x;
  }

  void ReadingType::
  currency (::std::unique_ptr< currency_type > x)
  {
    this->currency_.set (std::move (x));
  }

  const ReadingType::dataQualifier_optional& ReadingType::
  dataQualifier () const
  {
    return this->dataQualifier_;
  }

  ReadingType::dataQualifier_optional& ReadingType::
  dataQualifier ()
  {
    return this->dataQualifier_;
  }

  void ReadingType::
  dataQualifier (const dataQualifier_type& x)
  {
    this->dataQualifier_.set (x);
  }

  void ReadingType::
  dataQualifier (const dataQualifier_optional& x)
  {
    this->dataQualifier_ = x;
  }

  void ReadingType::
  dataQualifier (::std::unique_ptr< dataQualifier_type > x)
  {
    this->dataQualifier_.set (std::move (x));
  }

  const ReadingType::defaultQuality_optional& ReadingType::
  defaultQuality () const
  {
    return this->defaultQuality_;
  }

  ReadingType::defaultQuality_optional& ReadingType::
  defaultQuality ()
  {
    return this->defaultQuality_;
  }

  void ReadingType::
  defaultQuality (const defaultQuality_type& x)
  {
    this->defaultQuality_.set (x);
  }

  void ReadingType::
  defaultQuality (const defaultQuality_optional& x)
  {
    this->defaultQuality_ = x;
  }

  void ReadingType::
  defaultQuality (::std::unique_ptr< defaultQuality_type > x)
  {
    this->defaultQuality_.set (std::move (x));
  }

  const ReadingType::flowDirection_optional& ReadingType::
  flowDirection () const
  {
    return this->flowDirection_;
  }

  ReadingType::flowDirection_optional& ReadingType::
  flowDirection ()
  {
    return this->flowDirection_;
  }

  void ReadingType::
  flowDirection (const flowDirection_type& x)
  {
    this->flowDirection_.set (x);
  }

  void ReadingType::
  flowDirection (const flowDirection_optional& x)
  {
    this->flowDirection_ = x;
  }

  void ReadingType::
  flowDirection (::std::unique_ptr< flowDirection_type > x)
  {
    this->flowDirection_.set (std::move (x));
  }

  const ReadingType::intervalLength_optional& ReadingType::
  intervalLength () const
  {
    return this->intervalLength_;
  }

  ReadingType::intervalLength_optional& ReadingType::
  intervalLength ()
  {
    return this->intervalLength_;
  }

  void ReadingType::
  intervalLength (const intervalLength_type& x)
  {
    this->intervalLength_.set (x);
  }

  void ReadingType::
  intervalLength (const intervalLength_optional& x)
  {
    this->intervalLength_ = x;
  }

  void ReadingType::
  intervalLength (::std::unique_ptr< intervalLength_type > x)
  {
    this->intervalLength_.set (std::move (x));
  }

  const ReadingType::kind_optional& ReadingType::
  kind () const
  {
    return this->kind_;
  }

  ReadingType::kind_optional& ReadingType::
  kind ()
  {
    return this->kind_;
  }

  void ReadingType::
  kind (const kind_type& x)
  {
    this->kind_.set (x);
  }

  void ReadingType::
  kind (const kind_optional& x)
  {
    this->kind_ = x;
  }

  void ReadingType::
  kind (::std::unique_ptr< kind_type > x)
  {
    this->kind_.set (std::move (x));
  }

  const ReadingType::phase_optional& ReadingType::
  phase () const
  {
    return this->phase_;
  }

  ReadingType::phase_optional& ReadingType::
  phase ()
  {
    return this->phase_;
  }

  void ReadingType::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void ReadingType::
  phase (const phase_optional& x)
  {
    this->phase_ = x;
  }

  void ReadingType::
  phase (::std::unique_ptr< phase_type > x)
  {
    this->phase_.set (std::move (x));
  }

  const ReadingType::powerOfTenMultiplier_optional& ReadingType::
  powerOfTenMultiplier () const
  {
    return this->powerOfTenMultiplier_;
  }

  ReadingType::powerOfTenMultiplier_optional& ReadingType::
  powerOfTenMultiplier ()
  {
    return this->powerOfTenMultiplier_;
  }

  void ReadingType::
  powerOfTenMultiplier (const powerOfTenMultiplier_type& x)
  {
    this->powerOfTenMultiplier_.set (x);
  }

  void ReadingType::
  powerOfTenMultiplier (const powerOfTenMultiplier_optional& x)
  {
    this->powerOfTenMultiplier_ = x;
  }

  void ReadingType::
  powerOfTenMultiplier (::std::unique_ptr< powerOfTenMultiplier_type > x)
  {
    this->powerOfTenMultiplier_.set (std::move (x));
  }

  const ReadingType::timeAttribute_optional& ReadingType::
  timeAttribute () const
  {
    return this->timeAttribute_;
  }

  ReadingType::timeAttribute_optional& ReadingType::
  timeAttribute ()
  {
    return this->timeAttribute_;
  }

  void ReadingType::
  timeAttribute (const timeAttribute_type& x)
  {
    this->timeAttribute_.set (x);
  }

  void ReadingType::
  timeAttribute (const timeAttribute_optional& x)
  {
    this->timeAttribute_ = x;
  }

  void ReadingType::
  timeAttribute (::std::unique_ptr< timeAttribute_type > x)
  {
    this->timeAttribute_.set (std::move (x));
  }

  const ReadingType::tou_optional& ReadingType::
  tou () const
  {
    return this->tou_;
  }

  ReadingType::tou_optional& ReadingType::
  tou ()
  {
    return this->tou_;
  }

  void ReadingType::
  tou (const tou_type& x)
  {
    this->tou_.set (x);
  }

  void ReadingType::
  tou (const tou_optional& x)
  {
    this->tou_ = x;
  }

  void ReadingType::
  tou (::std::unique_ptr< tou_type > x)
  {
    this->tou_.set (std::move (x));
  }

  const ReadingType::uom_optional& ReadingType::
  uom () const
  {
    return this->uom_;
  }

  ReadingType::uom_optional& ReadingType::
  uom ()
  {
    return this->uom_;
  }

  void ReadingType::
  uom (const uom_type& x)
  {
    this->uom_.set (x);
  }

  void ReadingType::
  uom (const uom_optional& x)
  {
    this->uom_ = x;
  }

  void ReadingType::
  uom (::std::unique_ptr< uom_type > x)
  {
    this->uom_.set (std::move (x));
  }

  const ReadingType::cpp_optional& ReadingType::
  cpp () const
  {
    return this->cpp_;
  }

  ReadingType::cpp_optional& ReadingType::
  cpp ()
  {
    return this->cpp_;
  }

  void ReadingType::
  cpp (const cpp_type& x)
  {
    this->cpp_.set (x);
  }

  void ReadingType::
  cpp (const cpp_optional& x)
  {
    this->cpp_ = x;
  }

  void ReadingType::
  cpp (::std::unique_ptr< cpp_type > x)
  {
    this->cpp_.set (std::move (x));
  }

  const ReadingType::interharmonic_optional& ReadingType::
  interharmonic () const
  {
    return this->interharmonic_;
  }

  ReadingType::interharmonic_optional& ReadingType::
  interharmonic ()
  {
    return this->interharmonic_;
  }

  void ReadingType::
  interharmonic (const interharmonic_type& x)
  {
    this->interharmonic_.set (x);
  }

  void ReadingType::
  interharmonic (const interharmonic_optional& x)
  {
    this->interharmonic_ = x;
  }

  void ReadingType::
  interharmonic (::std::unique_ptr< interharmonic_type > x)
  {
    this->interharmonic_.set (std::move (x));
  }

  const ReadingType::measuringPeriod_optional& ReadingType::
  measuringPeriod () const
  {
    return this->measuringPeriod_;
  }

  ReadingType::measuringPeriod_optional& ReadingType::
  measuringPeriod ()
  {
    return this->measuringPeriod_;
  }

  void ReadingType::
  measuringPeriod (const measuringPeriod_type& x)
  {
    this->measuringPeriod_.set (x);
  }

  void ReadingType::
  measuringPeriod (const measuringPeriod_optional& x)
  {
    this->measuringPeriod_ = x;
  }

  void ReadingType::
  measuringPeriod (::std::unique_ptr< measuringPeriod_type > x)
  {
    this->measuringPeriod_.set (std::move (x));
  }

  const ReadingType::argument_optional& ReadingType::
  argument () const
  {
    return this->argument_;
  }

  ReadingType::argument_optional& ReadingType::
  argument ()
  {
    return this->argument_;
  }

  void ReadingType::
  argument (const argument_type& x)
  {
    this->argument_.set (x);
  }

  void ReadingType::
  argument (const argument_optional& x)
  {
    this->argument_ = x;
  }

  void ReadingType::
  argument (::std::unique_ptr< argument_type > x)
  {
    this->argument_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace espi
{
  // ReadingType
  //

  ReadingType::
  ReadingType ()
  : ::espi::IdentifiedObject (),
    accumulationBehaviour_ (this),
    commodity_ (this),
    consumptionTier_ (this),
    currency_ (this),
    dataQualifier_ (this),
    defaultQuality_ (this),
    flowDirection_ (this),
    intervalLength_ (this),
    kind_ (this),
    phase_ (this),
    powerOfTenMultiplier_ (this),
    timeAttribute_ (this),
    tou_ (this),
    uom_ (this),
    cpp_ (this),
    interharmonic_ (this),
    measuringPeriod_ (this),
    argument_ (this)
  {
  }

  ReadingType::
  ReadingType (const ReadingType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::espi::IdentifiedObject (x, f, c),
    accumulationBehaviour_ (x.accumulationBehaviour_, f, this),
    commodity_ (x.commodity_, f, this),
    consumptionTier_ (x.consumptionTier_, f, this),
    currency_ (x.currency_, f, this),
    dataQualifier_ (x.dataQualifier_, f, this),
    defaultQuality_ (x.defaultQuality_, f, this),
    flowDirection_ (x.flowDirection_, f, this),
    intervalLength_ (x.intervalLength_, f, this),
    kind_ (x.kind_, f, this),
    phase_ (x.phase_, f, this),
    powerOfTenMultiplier_ (x.powerOfTenMultiplier_, f, this),
    timeAttribute_ (x.timeAttribute_, f, this),
    tou_ (x.tou_, f, this),
    uom_ (x.uom_, f, this),
    cpp_ (x.cpp_, f, this),
    interharmonic_ (x.interharmonic_, f, this),
    measuringPeriod_ (x.measuringPeriod_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  ReadingType::
  ReadingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::espi::IdentifiedObject (e, f | ::xml_schema::flags::base, c),
    accumulationBehaviour_ (this),
    commodity_ (this),
    consumptionTier_ (this),
    currency_ (this),
    dataQualifier_ (this),
    defaultQuality_ (this),
    flowDirection_ (this),
    intervalLength_ (this),
    kind_ (this),
    phase_ (this),
    powerOfTenMultiplier_ (this),
    timeAttribute_ (this),
    tou_ (this),
    uom_ (this),
    cpp_ (this),
    interharmonic_ (this),
    measuringPeriod_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReadingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::espi::IdentifiedObject::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accumulationBehaviour
      //
      if (n.name () == "accumulationBehaviour" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< accumulationBehaviour_type > r (
          accumulationBehaviour_traits::create (i, f, this));

        if (!this->accumulationBehaviour_)
        {
          this->accumulationBehaviour_.set (::std::move (r));
          continue;
        }
      }

      // commodity
      //
      if (n.name () == "commodity" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< commodity_type > r (
          commodity_traits::create (i, f, this));

        if (!this->commodity_)
        {
          this->commodity_.set (::std::move (r));
          continue;
        }
      }

      // consumptionTier
      //
      if (n.name () == "consumptionTier" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< consumptionTier_type > r (
          consumptionTier_traits::create (i, f, this));

        if (!this->consumptionTier_)
        {
          this->consumptionTier_.set (::std::move (r));
          continue;
        }
      }

      // currency
      //
      if (n.name () == "currency" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< currency_type > r (
          currency_traits::create (i, f, this));

        if (!this->currency_)
        {
          this->currency_.set (::std::move (r));
          continue;
        }
      }

      // dataQualifier
      //
      if (n.name () == "dataQualifier" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< dataQualifier_type > r (
          dataQualifier_traits::create (i, f, this));

        if (!this->dataQualifier_)
        {
          this->dataQualifier_.set (::std::move (r));
          continue;
        }
      }

      // defaultQuality
      //
      if (n.name () == "defaultQuality" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< defaultQuality_type > r (
          defaultQuality_traits::create (i, f, this));

        if (!this->defaultQuality_)
        {
          this->defaultQuality_.set (::std::move (r));
          continue;
        }
      }

      // flowDirection
      //
      if (n.name () == "flowDirection" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< flowDirection_type > r (
          flowDirection_traits::create (i, f, this));

        if (!this->flowDirection_)
        {
          this->flowDirection_.set (::std::move (r));
          continue;
        }
      }

      // intervalLength
      //
      if (n.name () == "intervalLength" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< intervalLength_type > r (
          intervalLength_traits::create (i, f, this));

        if (!this->intervalLength_)
        {
          this->intervalLength_.set (::std::move (r));
          continue;
        }
      }

      // kind
      //
      if (n.name () == "kind" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< kind_type > r (
          kind_traits::create (i, f, this));

        if (!this->kind_)
        {
          this->kind_.set (::std::move (r));
          continue;
        }
      }

      // phase
      //
      if (n.name () == "phase" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< phase_type > r (
          phase_traits::create (i, f, this));

        if (!this->phase_)
        {
          this->phase_.set (::std::move (r));
          continue;
        }
      }

      // powerOfTenMultiplier
      //
      if (n.name () == "powerOfTenMultiplier" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< powerOfTenMultiplier_type > r (
          powerOfTenMultiplier_traits::create (i, f, this));

        if (!this->powerOfTenMultiplier_)
        {
          this->powerOfTenMultiplier_.set (::std::move (r));
          continue;
        }
      }

      // timeAttribute
      //
      if (n.name () == "timeAttribute" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< timeAttribute_type > r (
          timeAttribute_traits::create (i, f, this));

        if (!this->timeAttribute_)
        {
          this->timeAttribute_.set (::std::move (r));
          continue;
        }
      }

      // tou
      //
      if (n.name () == "tou" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< tou_type > r (
          tou_traits::create (i, f, this));

        if (!this->tou_)
        {
          this->tou_.set (::std::move (r));
          continue;
        }
      }

      // uom
      //
      if (n.name () == "uom" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< uom_type > r (
          uom_traits::create (i, f, this));

        if (!this->uom_)
        {
          this->uom_.set (::std::move (r));
          continue;
        }
      }

      // cpp
      //
      if (n.name () == "cpp" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< cpp_type > r (
          cpp_traits::create (i, f, this));

        if (!this->cpp_)
        {
          this->cpp_.set (::std::move (r));
          continue;
        }
      }

      // interharmonic
      //
      if (n.name () == "interharmonic" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< interharmonic_type > r (
          interharmonic_traits::create (i, f, this));

        if (!this->interharmonic_)
        {
          this->interharmonic_.set (::std::move (r));
          continue;
        }
      }

      // measuringPeriod
      //
      if (n.name () == "measuringPeriod" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< measuringPeriod_type > r (
          measuringPeriod_traits::create (i, f, this));

        if (!this->measuringPeriod_)
        {
          this->measuringPeriod_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "http://naesb.org/espi")
      {
        ::std::unique_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        if (!this->argument_)
        {
          this->argument_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReadingType* ReadingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReadingType (*this, f, c);
  }

  ReadingType& ReadingType::
  operator= (const ReadingType& x)
  {
    if (this != &x)
    {
      static_cast< ::espi::IdentifiedObject& > (*this) = x;
      this->accumulationBehaviour_ = x.accumulationBehaviour_;
      this->commodity_ = x.commodity_;
      this->consumptionTier_ = x.consumptionTier_;
      this->currency_ = x.currency_;
      this->dataQualifier_ = x.dataQualifier_;
      this->defaultQuality_ = x.defaultQuality_;
      this->flowDirection_ = x.flowDirection_;
      this->intervalLength_ = x.intervalLength_;
      this->kind_ = x.kind_;
      this->phase_ = x.phase_;
      this->powerOfTenMultiplier_ = x.powerOfTenMultiplier_;
      this->timeAttribute_ = x.timeAttribute_;
      this->tou_ = x.tou_;
      this->uom_ = x.uom_;
      this->cpp_ = x.cpp_;
      this->interharmonic_ = x.interharmonic_;
      this->measuringPeriod_ = x.measuringPeriod_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  ReadingType::
  ~ReadingType ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace espi
{
  ::std::ostream&
  operator<< (::std::ostream& o, const ReadingType& i)
  {
    o << static_cast< const ::espi::IdentifiedObject& > (i);

    if (i.accumulationBehaviour ())
    {
      o << ::std::endl << "accumulationBehaviour: " << *i.accumulationBehaviour ();
    }

    if (i.commodity ())
    {
      o << ::std::endl << "commodity: " << *i.commodity ();
    }

    if (i.consumptionTier ())
    {
      o << ::std::endl << "consumptionTier: " << *i.consumptionTier ();
    }

    if (i.currency ())
    {
      o << ::std::endl << "currency: " << *i.currency ();
    }

    if (i.dataQualifier ())
    {
      o << ::std::endl << "dataQualifier: " << *i.dataQualifier ();
    }

    if (i.defaultQuality ())
    {
      o << ::std::endl << "defaultQuality: " << *i.defaultQuality ();
    }

    if (i.flowDirection ())
    {
      o << ::std::endl << "flowDirection: " << *i.flowDirection ();
    }

    if (i.intervalLength ())
    {
      o << ::std::endl << "intervalLength: " << *i.intervalLength ();
    }

    if (i.kind ())
    {
      o << ::std::endl << "kind: " << *i.kind ();
    }

    if (i.phase ())
    {
      o << ::std::endl << "phase: " << *i.phase ();
    }

    if (i.powerOfTenMultiplier ())
    {
      o << ::std::endl << "powerOfTenMultiplier: " << *i.powerOfTenMultiplier ();
    }

    if (i.timeAttribute ())
    {
      o << ::std::endl << "timeAttribute: " << *i.timeAttribute ();
    }

    if (i.tou ())
    {
      o << ::std::endl << "tou: " << *i.tou ();
    }

    if (i.uom ())
    {
      o << ::std::endl << "uom: " << *i.uom ();
    }

    if (i.cpp ())
    {
      o << ::std::endl << "cpp: " << *i.cpp ();
    }

    if (i.interharmonic ())
    {
      o << ::std::endl << "interharmonic: " << *i.interharmonic ();
    }

    if (i.measuringPeriod ())
    {
      o << ::std::endl << "measuringPeriod: " << *i.measuringPeriod ();
    }

    if (i.argument ())
    {
      o << ::std::endl << "argument: " << *i.argument ();
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace espi
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace espi
{
  void
  operator<< (::xercesc::DOMElement& e, const ReadingType& i)
  {
    e << static_cast< const ::espi::IdentifiedObject& > (i);

    // accumulationBehaviour
    //
    if (i.accumulationBehaviour ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "accumulationBehaviour",
          "http://naesb.org/espi",
          e));

      s << *i.accumulationBehaviour ();
    }

    // commodity
    //
    if (i.commodity ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "commodity",
          "http://naesb.org/espi",
          e));

      s << *i.commodity ();
    }

    // consumptionTier
    //
    if (i.consumptionTier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "consumptionTier",
          "http://naesb.org/espi",
          e));

      s << *i.consumptionTier ();
    }

    // currency
    //
    if (i.currency ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "currency",
          "http://naesb.org/espi",
          e));

      s << *i.currency ();
    }

    // dataQualifier
    //
    if (i.dataQualifier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataQualifier",
          "http://naesb.org/espi",
          e));

      s << *i.dataQualifier ();
    }

    // defaultQuality
    //
    if (i.defaultQuality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "defaultQuality",
          "http://naesb.org/espi",
          e));

      s << *i.defaultQuality ();
    }

    // flowDirection
    //
    if (i.flowDirection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flowDirection",
          "http://naesb.org/espi",
          e));

      s << *i.flowDirection ();
    }

    // intervalLength
    //
    if (i.intervalLength ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "intervalLength",
          "http://naesb.org/espi",
          e));

      s << *i.intervalLength ();
    }

    // kind
    //
    if (i.kind ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kind",
          "http://naesb.org/espi",
          e));

      s << *i.kind ();
    }

    // phase
    //
    if (i.phase ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "phase",
          "http://naesb.org/espi",
          e));

      s << *i.phase ();
    }

    // powerOfTenMultiplier
    //
    if (i.powerOfTenMultiplier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "powerOfTenMultiplier",
          "http://naesb.org/espi",
          e));

      s << *i.powerOfTenMultiplier ();
    }

    // timeAttribute
    //
    if (i.timeAttribute ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeAttribute",
          "http://naesb.org/espi",
          e));

      s << *i.timeAttribute ();
    }

    // tou
    //
    if (i.tou ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tou",
          "http://naesb.org/espi",
          e));

      s << *i.tou ();
    }

    // uom
    //
    if (i.uom ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "uom",
          "http://naesb.org/espi",
          e));

      s << *i.uom ();
    }

    // cpp
    //
    if (i.cpp ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cpp",
          "http://naesb.org/espi",
          e));

      s << *i.cpp ();
    }

    // interharmonic
    //
    if (i.interharmonic ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interharmonic",
          "http://naesb.org/espi",
          e));

      s << *i.interharmonic ();
    }

    // measuringPeriod
    //
    if (i.measuringPeriod ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "measuringPeriod",
          "http://naesb.org/espi",
          e));

      s << *i.measuringPeriod ();
    }

    // argument
    //
    if (i.argument ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "http://naesb.org/espi",
          e));

      s << *i.argument ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

